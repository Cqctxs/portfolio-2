/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 .\public\models\Background.glb 
*/

import React, { useEffect, useRef } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";

export function Model({ icosphereRef, onLoad, ...props }) {
  const group = React.useRef();
  const { nodes, materials, animations } = useGLTF("/models/Background.glb");
  const { actions } = useAnimations(animations, group);

  // Notify parent when icosphere is mounted
  useEffect(() => {
    if (icosphereRef.current && onLoad) {
      onLoad();
    }
  }, [icosphereRef, onLoad]);

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Empty" position={[0, 0, -8]} />
        <mesh
          name="Plane"
          geometry={nodes.Plane.geometry}
          material={materials["Material.004"]}
        />
        <mesh
          name="Cactus1"
          geometry={nodes.Cactus1.geometry}
          material={materials["Material.003"]}
          position={[-0.252, 0, 0]}
        />
        <mesh
          name="Cactus1003"
          geometry={nodes.Cactus1003.geometry}
          material={materials["Material.003"]}
          position={[0.299, 0, 0]}
        />
        <mesh
          name="Cactus1004"
          geometry={nodes.Cactus1004.geometry}
          material={materials["Material.003"]}
          position={[0.315, 0, 0]}
        />
        <mesh
          name="Cactus1005"
          geometry={nodes.Cactus1005.geometry}
          material={materials["Material.003"]}
          position={[-0.173, 0, 0]}
        />
        <mesh
          name="Cactus1006"
          geometry={nodes.Cactus1006.geometry}
          material={materials["Material.003"]}
          position={[0.236, 0, 0]}
        />
        <mesh
          name="Cactus1007"
          geometry={nodes.Cactus1007.geometry}
          material={materials["Material.003"]}
          position={[-0.504, 0, 0]}
        />
        <mesh
          name="Plane001"
          geometry={nodes.Plane001.geometry}
          material={materials["Material.006"]}
        />
        <mesh
          ref={icosphereRef}
          name="Icosphere"
          geometry={nodes.Icosphere.geometry}
          material={materials["Material.005"]}
          position={[0, 0.014, -321.833]}
          scale={102.712}
        />
      </group>
    </group>
  );
}

useGLTF.preload("/models/Background.glb");

// Shared animation time
const sharedAnimationTime = { current: 0 };

// Camera Animation Component
export function CameraAnimation({ icosphereRef, mouseXRef, mouseYRef }) {
  const { camera } = useThree();
  const startZRef = useRef(null);
  const currentX = useRef(0);
  const currentY = useRef(0);
  const parallaxFactorX = 1; // Adjusted for normalized coordinates
  const parallaxFactorY = 0.3; // Adjusted for normalized coordinates

  useFrame((state, delta) => {
    // Store initial Z position
    if (startZRef.current === null) {
      startZRef.current = camera.position.z;
    }

    // Increment shared time
    sharedAnimationTime.current += delta;

    // Total duration: 5 seconds
    const duration = 5;
    const progress = (sharedAnimationTime.current % duration) / duration; // 0 to 1

    const zOffset = progress * -32;
    camera.position.z = startZRef.current + zOffset;

    // Move Icosphere in sync with camera
    if (icosphereRef?.current) {
      icosphereRef.current.position.z = -321.833 + zOffset;
    }

    // Smooth parallax effect with lerp (linear interpolation)
    // This creates smooth, performant movement
    const targetX = mouseXRef.current * parallaxFactorX;
    const targetY = mouseYRef.current * parallaxFactorY;

    // Lerp factor - higher value = faster response (0.05 = smooth, 0.1 = snappier)
    const lerpFactor = 0.05;

    currentX.current += (targetX - currentX.current) * lerpFactor;
    currentY.current += (targetY - currentY.current) * lerpFactor;

    camera.position.x = currentX.current;
    camera.position.y = 0.74 + currentY.current;
  });

  return null;
}
